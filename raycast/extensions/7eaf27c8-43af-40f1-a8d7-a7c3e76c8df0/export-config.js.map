{
  "version": 3,
  "sources": ["../src/export-config.tsx", "../src/storage.ts", "../src/types.ts"],
  "sourcesContent": ["import {\n  Action,\n  ActionPanel,\n  Clipboard,\n  Detail,\n  showToast,\n  Toast,\n} from \"@raycast/api\";\nimport { useEffect, useState } from \"react\";\nimport { exportConfigToJson } from \"./storage\";\nimport { writeFileSync } from \"fs\";\nimport { join } from \"path\";\nimport { homedir } from \"os\";\n\nexport default function ExportConfig() {\n  const [json, setJson] = useState<string>(\"\");\n  const [isLoading, setIsLoading] = useState(true);\n\n  useEffect(() => {\n    async function load() {\n      const exported = await exportConfigToJson();\n      setJson(exported);\n      setIsLoading(false);\n    }\n    load();\n  }, []);\n\n  async function copyToClipboard() {\n    await Clipboard.copy(json);\n    await showToast({\n      style: Toast.Style.Success,\n      title: \"Copied to clipboard\",\n    });\n  }\n\n  async function saveToDownloads() {\n    try {\n      const downloadsPath = join(\n        homedir(),\n        \"Downloads\",\n        \"leader-key-config.json\",\n      );\n      writeFileSync(downloadsPath, json, \"utf-8\");\n      await showToast({\n        style: Toast.Style.Success,\n        title: \"Saved to Downloads\",\n        message: \"leader-key-config.json\",\n      });\n    } catch (e) {\n      const message = e instanceof Error ? e.message : \"Unknown error\";\n      await showToast({\n        style: Toast.Style.Failure,\n        title: \"Failed to save\",\n        message,\n      });\n    }\n  }\n\n  const markdown = isLoading\n    ? \"Loading...\"\n    : `# Leader Key Config\\n\\nThis config is compatible with the [Leader Key app](https://github.com/mikker/LeaderKey).\\n\\n\\`\\`\\`json\\n${json}\\n\\`\\`\\``;\n\n  return (\n    <Detail\n      isLoading={isLoading}\n      markdown={markdown}\n      actions={\n        <ActionPanel>\n          <Action title=\"Copy to Clipboard\" onAction={copyToClipboard} />\n          <Action title=\"Save to Downloads\" onAction={saveToDownloads} />\n        </ActionPanel>\n      }\n    />\n  );\n}\n", "import { LocalStorage } from \"@raycast/api\";\nimport {\n  ActionOrGroup,\n  RootConfig,\n  ConfigData,\n  isGroup,\n  Action,\n  Group,\n  LegacyMappingsData,\n  ActionType,\n} from \"./types\";\n\nconst STORAGE_KEY = \"leader-key-config\";\nconst LEGACY_STORAGE_KEY = \"key-mappings\";\nconst CURRENT_VERSION = 1;\n\ntype Platform = \"mac\" | \"windows\";\n\nconst platform: Platform = process.platform === \"win32\" ? \"windows\" : \"mac\";\n\nconst platformApps = {\n  mac: {\n    browser: { label: \"Safari\", value: \"/Applications/Safari.app\" },\n    fileManager: {\n      label: \"Finder\",\n      value: \"/System/Library/CoreServices/Finder.app\",\n    },\n    terminal: {\n      label: \"Terminal\",\n      value: \"/System/Applications/Utilities/Terminal.app\",\n    },\n    calculator: {\n      label: \"Calculator\",\n      value: \"/System/Applications/Calculator.app\",\n    },\n    notes: { label: \"Notes\", value: \"/System/Applications/Notes.app\" },\n  },\n  windows: {\n    browser: { label: \"Edge\", value: \"msedge.exe\" },\n    fileManager: { label: \"Explorer\", value: \"explorer.exe\" },\n    terminal: { label: \"Command Prompt\", value: \"cmd.exe\" },\n    calculator: { label: \"Calculator\", value: \"calc.exe\" },\n    notes: { label: \"Notepad\", value: \"notepad.exe\" },\n  },\n} as const;\n\nconst apps = platformApps[platform];\n\nconst DEFAULT_CONFIG: RootConfig = {\n  type: \"group\",\n  actions: [\n    {\n      id: \"default-a\",\n      key: \"a\",\n      type: \"group\",\n      label: \"Applications\",\n      actions: [\n        {\n          id: \"default-ab\",\n          key: \"b\",\n          type: \"application\",\n          label: apps.browser.label,\n          value: apps.browser.value,\n        },\n        {\n          id: \"default-at\",\n          key: \"t\",\n          type: \"application\",\n          label: apps.terminal.label,\n          value: apps.terminal.value,\n        },\n        {\n          id: \"default-af\",\n          key: \"f\",\n          type: \"application\",\n          label: apps.fileManager.label,\n          value: apps.fileManager.value,\n        },\n        {\n          id: \"default-ac\",\n          key: \"c\",\n          type: \"application\",\n          label: apps.calculator.label,\n          value: apps.calculator.value,\n        },\n        {\n          id: \"default-an\",\n          key: \"n\",\n          type: \"application\",\n          label: apps.notes.label,\n          value: apps.notes.value,\n        },\n      ],\n    },\n    {\n      id: \"default-u\",\n      key: \"u\",\n      type: \"group\",\n      label: \"URLs\",\n      actions: [\n        {\n          id: \"default-ug\",\n          key: \"g\",\n          type: \"url\",\n          label: \"Google\",\n          value: \"https://google.com\",\n        },\n        {\n          id: \"default-uh\",\n          key: \"h\",\n          type: \"url\",\n          label: \"GitHub\",\n          value: \"https://github.com\",\n        },\n      ],\n    },\n  ],\n};\n\nexport async function getConfig(): Promise<RootConfig> {\n  const stored = await LocalStorage.getItem<string>(STORAGE_KEY);\n\n  if (!stored) {\n    const migrated = await migrateFromLegacy();\n    if (migrated) {\n      return migrated;\n    }\n    await saveConfig(DEFAULT_CONFIG);\n    return DEFAULT_CONFIG;\n  }\n\n  try {\n    const data: ConfigData = JSON.parse(stored);\n    return data.root;\n  } catch {\n    return DEFAULT_CONFIG;\n  }\n}\n\nexport async function saveConfig(config: RootConfig): Promise<void> {\n  const data: ConfigData = {\n    root: config,\n    version: CURRENT_VERSION,\n  };\n  await LocalStorage.setItem(STORAGE_KEY, JSON.stringify(data));\n}\n\nexport async function addItemToGroup(\n  config: RootConfig,\n  parentPath: string[],\n  item: ActionOrGroup,\n): Promise<RootConfig> {\n  const newConfig = structuredClone(config);\n  const parent = findGroupByPath(newConfig, parentPath);\n  if (parent) {\n    parent.actions.push(item);\n  }\n  return newConfig;\n}\n\nexport async function updateItem(\n  config: RootConfig,\n  path: string[],\n  updates: Partial<Action> | Partial<Group>,\n): Promise<RootConfig> {\n  const newConfig = structuredClone(config);\n  const parentPath = path.slice(0, -1);\n  const itemId = path[path.length - 1];\n  const parent =\n    parentPath.length === 0\n      ? newConfig\n      : findGroupByPath(newConfig, parentPath);\n\n  if (parent) {\n    const index = parent.actions.findIndex((a) => a.id === itemId);\n    if (index !== -1) {\n      parent.actions[index] = {\n        ...parent.actions[index],\n        ...updates,\n      } as ActionOrGroup;\n    }\n  }\n  return newConfig;\n}\n\nexport async function deleteItem(\n  config: RootConfig,\n  path: string[],\n): Promise<RootConfig> {\n  const newConfig = structuredClone(config);\n  const parentPath = path.slice(0, -1);\n  const itemId = path[path.length - 1];\n  const parent =\n    parentPath.length === 0\n      ? newConfig\n      : findGroupByPath(newConfig, parentPath);\n\n  if (parent) {\n    parent.actions = parent.actions.filter((a) => a.id !== itemId);\n  }\n  return newConfig;\n}\n\nexport function findGroupByPath(\n  config: RootConfig | Group,\n  path: string[],\n): Group | null {\n  if (path.length === 0) {\n    return config as Group;\n  }\n\n  const [currentId, ...rest] = path;\n  const child = config.actions.find((a) => a.id === currentId);\n\n  if (!child || !isGroup(child)) {\n    return null;\n  }\n\n  if (rest.length === 0) {\n    return child;\n  }\n\n  return findGroupByPath(child, rest);\n}\n\nexport function findItemByPath(\n  config: RootConfig,\n  path: string[],\n): ActionOrGroup | null {\n  if (path.length === 0) {\n    return null;\n  }\n\n  const parentPath = path.slice(0, -1);\n  const itemId = path[path.length - 1];\n  const parent =\n    parentPath.length === 0 ? config : findGroupByPath(config, parentPath);\n\n  if (!parent) {\n    return null;\n  }\n\n  return parent.actions.find((a) => a.id === itemId) || null;\n}\n\nexport function resolveBrowser(\n  config: RootConfig,\n  actionPath: string[],\n): string | undefined {\n  const item = findItemByPath(config, actionPath);\n  if (item && !isGroup(item) && item.browser) {\n    return item.browser;\n  }\n\n  for (let i = actionPath.length - 1; i >= 1; i--) {\n    const ancestorPath = actionPath.slice(0, i);\n    const ancestor = findItemByPath(config, ancestorPath);\n    if (ancestor && isGroup(ancestor) && ancestor.browser) {\n      return ancestor.browser;\n    }\n  }\n\n  return undefined;\n}\n\nexport function generateId(): string {\n  return Date.now().toString(36) + Math.random().toString(36).slice(2);\n}\n\nexport function checkKeyConflict(\n  group: Group | RootConfig,\n  newKey: string,\n  excludeId?: string,\n): { hasConflict: boolean; conflictLabel: string } {\n  for (const item of group.actions) {\n    if (excludeId && item.id === excludeId) continue;\n    if (item.key === newKey) {\n      return {\n        hasConflict: true,\n        conflictLabel:\n          item.label || (item.type === \"group\" ? \"a group\" : item.value),\n      };\n    }\n  }\n  return { hasConflict: false, conflictLabel: \"\" };\n}\n\nasync function migrateFromLegacy(): Promise<RootConfig | null> {\n  const stored = await LocalStorage.getItem<string>(LEGACY_STORAGE_KEY);\n  if (!stored) {\n    return null;\n  }\n\n  try {\n    const data: LegacyMappingsData = JSON.parse(stored);\n    const mappings = data.mappings;\n\n    if (!mappings || mappings.length === 0) {\n      return null;\n    }\n\n    const root: RootConfig = { type: \"group\", actions: [] };\n    const groupMap = new Map<string, Group>();\n\n    const groups = mappings.filter((m) => m.isGroup && !m.action);\n    for (const g of groups) {\n      const group: Group = {\n        id: g.id,\n        key: g.sequence,\n        type: \"group\",\n        label: g.groupName || g.label,\n        actions: [],\n      };\n      groupMap.set(g.sequence, group);\n    }\n\n    for (const m of mappings) {\n      if (m.isGroup && !m.action) continue;\n      if (!m.action) continue;\n\n      const action: Action = {\n        id: m.id,\n        key: m.sequence.length > 1 ? m.sequence.slice(-1) : m.sequence,\n        type: convertLegacyType(m.action.type),\n        label: m.label,\n        value: m.action.target,\n      };\n\n      if (m.sequence.length > 1) {\n        const prefix = m.sequence.slice(0, -1);\n        const parentGroup = groupMap.get(prefix);\n        if (parentGroup) {\n          parentGroup.actions.push(action);\n        } else {\n          let group = groupMap.get(prefix);\n          if (!group) {\n            group = {\n              id: generateId(),\n              key: prefix,\n              type: \"group\",\n              label: prefix.toUpperCase(),\n              actions: [],\n            };\n            groupMap.set(prefix, group);\n          }\n          group.actions.push(action);\n        }\n      } else {\n        root.actions.push(action);\n      }\n    }\n\n    for (const group of groupMap.values()) {\n      if (group.key.length === 1) {\n        root.actions.push(group);\n      }\n    }\n\n    await saveConfig(root);\n    return root;\n  } catch {\n    return null;\n  }\n}\n\nfunction convertLegacyType(legacyType: string): ActionType {\n  switch (legacyType) {\n    case \"app\":\n      return \"application\";\n    case \"url\":\n    case \"raycast\":\n      return \"url\";\n    case \"file\":\n      return \"folder\";\n    case \"shell\":\n      return \"command\";\n    default:\n      return \"application\";\n  }\n}\n\nexport interface LeaderKeyAction {\n  key: string;\n  type: \"application\" | \"url\" | \"folder\" | \"command\";\n  value: string;\n  label?: string;\n  browser?: string;\n}\n\nexport interface LeaderKeyGroup {\n  key: string;\n  type: \"group\";\n  label?: string;\n  actions: LeaderKeyItem[];\n  browser?: string;\n}\n\nexport type LeaderKeyItem = LeaderKeyAction | LeaderKeyGroup;\n\nexport interface LeaderKeyConfig {\n  type: \"group\";\n  actions: LeaderKeyItem[];\n}\n\nexport function importLeaderKeyConfig(external: LeaderKeyConfig): RootConfig {\n  function convertItem(\n    item: LeaderKeyItem,\n    prefix: string = \"\",\n  ): ActionOrGroup {\n    const id = generateId();\n\n    if (item.type === \"group\") {\n      const group = item as LeaderKeyGroup;\n      return {\n        id,\n        key: group.key,\n        type: \"group\",\n        label: group.label,\n        actions: group.actions.map((child) =>\n          convertItem(child, prefix + group.key),\n        ),\n        ...(group.browser ? { browser: group.browser } : {}),\n      } as Group;\n    } else {\n      const action = item as LeaderKeyAction;\n      return {\n        id,\n        key: action.key,\n        type: action.type,\n        label: action.label,\n        value: action.value,\n        ...(action.browser ? { browser: action.browser } : {}),\n      } as Action;\n    }\n  }\n\n  return {\n    type: \"group\",\n    actions: external.actions.map((item) => convertItem(item)),\n  };\n}\n\nexport function exportLeaderKeyConfig(config: RootConfig): LeaderKeyConfig {\n  function convertItem(item: ActionOrGroup): LeaderKeyItem {\n    if (isGroup(item)) {\n      const result: LeaderKeyGroup = {\n        key: item.key,\n        type: \"group\",\n        actions: item.actions.map(convertItem),\n      };\n      if (item.label) {\n        result.label = item.label;\n      }\n      if (item.browser) {\n        result.browser = item.browser;\n      }\n      return result;\n    } else {\n      const action = item as Action;\n      const result: LeaderKeyAction = {\n        key: action.key,\n        type: action.type,\n        value: action.value,\n      };\n      if (action.label) {\n        result.label = action.label;\n      }\n      if (action.browser) {\n        result.browser = action.browser;\n      }\n      return result;\n    }\n  }\n\n  return {\n    type: \"group\",\n    actions: config.actions.map(convertItem),\n  };\n}\n\nexport async function importConfigFromJson(\n  jsonString: string,\n): Promise<{ success: boolean; error?: string }> {\n  try {\n    const parsed = JSON.parse(jsonString);\n\n    if (!parsed || typeof parsed !== \"object\") {\n      return { success: false, error: \"Invalid JSON: not an object\" };\n    }\n    if (parsed.type !== \"group\") {\n      return {\n        success: false,\n        error: \"Invalid config: root must have type 'group'\",\n      };\n    }\n    if (!Array.isArray(parsed.actions)) {\n      return {\n        success: false,\n        error: \"Invalid config: missing 'actions' array\",\n      };\n    }\n\n    const config = importLeaderKeyConfig(parsed as LeaderKeyConfig);\n    await saveConfig(config);\n    return { success: true };\n  } catch (e) {\n    const message = e instanceof Error ? e.message : \"Unknown error\";\n    return { success: false, error: `Parse error: ${message}` };\n  }\n}\n\nexport async function exportConfigToJson(): Promise<string> {\n  const config = await getConfig();\n  const external = exportLeaderKeyConfig(config);\n  return JSON.stringify(external, null, 2);\n}\n", "export type ActionType = \"application\" | \"url\" | \"command\" | \"folder\";\n\nexport interface Action {\n  id: string;\n  key: string;\n  type: ActionType;\n  label?: string;\n  value: string;\n  browser?: string;\n}\n\nexport interface Group {\n  id: string;\n  key: string;\n  type: \"group\";\n  label?: string;\n  actions: ActionOrGroup[];\n  browser?: string;\n}\n\nexport type ActionOrGroup = Action | Group;\n\nexport function isGroup(item: ActionOrGroup): item is Group {\n  return item.type === \"group\";\n}\n\nexport function isAction(item: ActionOrGroup): item is Action {\n  return item.type !== \"group\";\n}\n\nexport interface RootConfig {\n  type: \"group\";\n  actions: ActionOrGroup[];\n}\n\nexport interface ConfigData {\n  root: RootConfig;\n  version: number;\n}\n\nexport type LegacyActionType = \"app\" | \"url\" | \"file\" | \"shell\" | \"raycast\";\n\nexport interface LegacyKeyMapping {\n  id: string;\n  sequence: string;\n  label: string;\n  description?: string;\n  isGroup?: boolean;\n  groupName?: string;\n  action?: {\n    type: LegacyActionType;\n    target: string;\n  };\n}\n\nexport interface LegacyMappingsData {\n  mappings: LegacyKeyMapping[];\n}\n"],
  "mappings": "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",
  "names": ["export_config_exports", "__export", "ExportConfig", "__toCommonJS", "import_api", "import_react", "import_api", "isGroup", "item", "STORAGE_KEY", "LEGACY_STORAGE_KEY", "CURRENT_VERSION", "platform", "platformApps", "apps", "DEFAULT_CONFIG", "getConfig", "stored", "migrated", "migrateFromLegacy", "saveConfig", "config", "data", "generateId", "migrateFromLegacy", "stored", "LEGACY_STORAGE_KEY", "mappings", "root", "groupMap", "groups", "m", "g", "group", "action", "convertLegacyType", "prefix", "parentGroup", "generateId", "saveConfig", "legacyType", "exportLeaderKeyConfig", "config", "convertItem", "item", "isGroup", "result", "action", "exportConfigToJson", "config", "getConfig", "external", "exportLeaderKeyConfig", "import_fs", "import_path", "import_os", "import_jsx_runtime", "ExportConfig", "json", "setJson", "isLoading", "setIsLoading", "load", "exported", "exportConfigToJson", "copyToClipboard", "saveToDownloads", "downloadsPath", "e", "message", "markdown"]
}
